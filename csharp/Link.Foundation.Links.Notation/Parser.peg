@namespace Link.Foundation.Links.Notation
@classname Parser
@using System.Linq
@members
{
    // Field to store parsed high quote value
    private string _highQuoteValue;

    /// <summary>
    /// Parse a multi-quote string dynamically for N >= 6 quotes.
    /// Stores result in _highQuoteValue field.
    /// </summary>
    /// <param name="input">The raw string including opening and closing quotes</param>
    /// <param name="quoteChar">The quote character (", ', or `)</param>
    /// <returns>True if parsing succeeded and the result matches the input length</returns>
    private bool ParseHighQuoteString(string input, char quoteChar)
    {
        _highQuoteValue = null;
        if (string.IsNullOrEmpty(input)) return false;

        // Count opening quotes
        int quoteCount = 0;
        while (quoteCount < input.Length && input[quoteCount] == quoteChar)
        {
            quoteCount++;
        }

        if (quoteCount < 6) return false; // Let the regular rules handle 1-5 quotes

        string openClose = new string(quoteChar, quoteCount);
        string escapeSeq = new string(quoteChar, quoteCount * 2);
        string escapeVal = new string(quoteChar, quoteCount);

        int pos = quoteCount; // Start after opening quotes
        var content = new System.Text.StringBuilder();

        while (pos < input.Length)
        {
            // Check for escape sequence (2*N quotes)
            if (pos + escapeSeq.Length <= input.Length &&
                input.Substring(pos, escapeSeq.Length) == escapeSeq)
            {
                content.Append(escapeVal);
                pos += escapeSeq.Length;
                continue;
            }

            // Check for closing quotes (exactly N quotes, not more)
            if (pos + quoteCount <= input.Length &&
                input.Substring(pos, quoteCount) == openClose)
            {
                // Make sure it's exactly N quotes (not followed by more of the same quote)
                int afterClose = pos + quoteCount;
                if (afterClose >= input.Length || input[afterClose] != quoteChar)
                {
                    // Found valid closing - check if we consumed the entire input
                    if (afterClose == input.Length)
                    {
                        _highQuoteValue = content.ToString();
                        return true;
                    }
                    return false;
                }
            }

            // Take next character
            content.Append(input[pos]);
            pos++;
        }

        // No closing quotes found
        return false;
    }
}
document <IList<Link<string>>> = #{ state["IndentationStack"] = new Stack<int>(); state["IndentationStack"].Push(0); state["BaseIndentation"] = -1; } skipEmptyLines l:links _ eof { l.ToLinksList() } / #{ state["IndentationStack"] = new Stack<int>(); state["IndentationStack"].Push(0); state["BaseIndentation"] = -1; } _ eof { new List<Link<string>>() }
skipEmptyLines = ([ \t]* [\r\n])*
links <IList<LinksGroup<string>>> = fl:firstLine list:line* POP_INDENTATION { new List<LinksGroup<string>> { fl }.Concat(list).ToList() }
firstLine <LinksGroup<string>> = SET_BASE_INDENTATION l:element { l }
line <LinksGroup<string>> = CHECK_INDENTATION l:element { l }
element <LinksGroup<string>> = e:anyLink PUSH_INDENTATION l:links { new LinksGroup<string>(e, l) } / e:anyLink { new LinksGroup<string>(e) }
referenceOrLink <Link<string>> = l:multiLineAnyLink { l } / i:reference { i }
anyLink <Link<string>> = ml:multiLineAnyLink eol { ml } / il:indentedIdLink { il } / sl:singleLineAnyLink { sl }
multiLineAnyLink <Link<string>> = multiLineValueLink / multiLineLink
singleLineAnyLink <Link<string>> = fl:singleLineLink eol { fl } / vl:singleLineValueLink eol { vl }
multiLineValueAndWhitespace <Link<string>> = value:referenceOrLink _ { value }
multiLineValues <IList<Link<string>>> = _ list:multiLineValueAndWhitespace* { list }
singleLineValueAndWhitespace <Link<string>> = __ value:referenceOrLink { value }
singleLineValues <IList<Link<string>>> = list:singleLineValueAndWhitespace+ { list }
singleLineLink <Link<string>> = __ id:(reference) __ ":" v:singleLineValues { new Link<string>(id, v) }
multiLineLink <Link<string>> = "(" _ id:(reference) _ ":" v:multiLineValues _ ")" { new Link<string>(id, v) }
singleLineValueLink <Link<string>> = v:singleLineValues { new Link<string>(v) }
multiLineValueLink <Link<string>> = "(" v:multiLineValues _ ")" { new Link<string>(v) }
indentedIdLink <Link<string>> = id:(reference) __ ":" eol { new Link<string>(id) }

// Reference can be quoted (with any number of quotes) or simple unquoted
// Order matters: try high quotes (6+), then quintuple down to single, then simple
reference <string> = highQuotedReference / quintupleQuotedReference / quadrupleQuotedReference / tripleQuotedReference / doubleQuotedReference / singleQuotedReference / simpleReference

simpleReference <string> = "" referenceSymbol+

// High quote sequences (6+ quotes) - use procedural parsing
// Capture everything that looks like a quoted string and validate
highQuotedReference <string> = &('""""""' / "''''''" / '``````') raw:highQuoteCapture { raw }

// Capture high quote content - match any characters including embedded quotes
highQuoteCapture <string> = raw:highQuoteDoubleRaw &{ ParseHighQuoteString(raw, '"') } { _highQuoteValue }
/ raw:highQuoteSingleRaw &{ ParseHighQuoteString(raw, '\'') } { _highQuoteValue }
/ raw:highQuoteBacktickRaw &{ ParseHighQuoteString(raw, '`') } { _highQuoteValue }

// Raw capture patterns - return string directly
highQuoteDoubleRaw <string> = "" ('"'+ highQuoteDoubleContent* '"'+)
highQuoteSingleRaw <string> = "" ("'"+ highQuoteSingleContent* "'"+)
highQuoteBacktickRaw <string> = "" ('`'+ highQuoteBacktickContent* '`'+)

// Content for high quote strings - match non-quote chars OR quote sequences followed by non-quote
highQuoteDoubleContent = [^"] / '"'+ &[^"]
highQuoteSingleContent = [^'] / "'"+ &[^']
highQuoteBacktickContent = [^`] / '`'+ &[^`]

// Single quotes (1 quote char) with escaping via doubling
singleQuotedReference <string> = doubleQuote1 / singleQuote1 / backtickQuote1

doubleQuote1 <string> = '"' r:doubleQuote1Content* '"' { string.Join("", r) }
doubleQuote1Content <string> = '""' { "\"" } / c:[^"] { c.ToString() }

singleQuote1 <string> = "'" r:singleQuote1Content* "'" { string.Join("", r) }
singleQuote1Content <string> = "''" { "'" } / c:[^'] { c.ToString() }

backtickQuote1 <string> = '`' r:backtickQuote1Content* '`' { string.Join("", r) }
backtickQuote1Content <string> = '``' { "`" } / c:[^`] { c.ToString() }

// Double quotes (2 quote chars)
doubleQuotedReference <string> = doubleQuote2 / singleQuote2 / backtickQuote2

doubleQuote2 <string> = '""' r:doubleQuote2Content* '""' { string.Join("", r) }
doubleQuote2Content <string> = '""""' { "\"\"" } / !'""' c:. { c.ToString() }

singleQuote2 <string> = "''" r:singleQuote2Content* "''" { string.Join("", r) }
singleQuote2Content <string> = "''''" { "''" } / !"''" c:. { c.ToString() }

backtickQuote2 <string> = '``' r:backtickQuote2Content* '``' { string.Join("", r) }
backtickQuote2Content <string> = '````' { "``" } / !'``' c:. { c.ToString() }

// Triple quotes (3 quote chars)
tripleQuotedReference <string> = doubleQuote3 / singleQuote3 / backtickQuote3

doubleQuote3 <string> = '"""' r:doubleQuote3Content* '"""' { string.Join("", r) }
doubleQuote3Content <string> = '""""""' { "\"\"\"" } / !'"""' c:. { c.ToString() }

singleQuote3 <string> = "'''" r:singleQuote3Content* "'''" { string.Join("", r) }
singleQuote3Content <string> = "''''''" { "'''" } / !"'''" c:. { c.ToString() }

backtickQuote3 <string> = '```' r:backtickQuote3Content* '```' { string.Join("", r) }
backtickQuote3Content <string> = '``````' { "```" } / !'```' c:. { c.ToString() }

// Quadruple quotes (4 quote chars)
quadrupleQuotedReference <string> = doubleQuote4 / singleQuote4 / backtickQuote4

doubleQuote4 <string> = '""""' r:doubleQuote4Content* '""""' { string.Join("", r) }
doubleQuote4Content <string> = '""""""""' { "\"\"\"\"" } / !'""""' c:. { c.ToString() }

singleQuote4 <string> = "''''" r:singleQuote4Content* "''''" { string.Join("", r) }
singleQuote4Content <string> = "''''''''''" { "''''" } / !"''''" c:. { c.ToString() }

backtickQuote4 <string> = '````' r:backtickQuote4Content* '````' { string.Join("", r) }
backtickQuote4Content <string> = '````````' { "````" } / !'````' c:. { c.ToString() }

// Quintuple quotes (5 quote chars)
quintupleQuotedReference <string> = doubleQuote5 / singleQuote5 / backtickQuote5

doubleQuote5 <string> = '"""""' r:doubleQuote5Content* '"""""' { string.Join("", r) }
doubleQuote5Content <string> = '""""""""""' { "\"\"\"\"\"" } / !'"""""' c:. { c.ToString() }

singleQuote5 <string> = "'''''" r:singleQuote5Content* "'''''" { string.Join("", r) }
singleQuote5Content <string> = "''''''''''" { "'''''" } / !"'''''" c:. { c.ToString() }

backtickQuote5 <string> = '`````' r:backtickQuote5Content* '`````' { string.Join("", r) }
backtickQuote5Content <string> = '``````````' { "`````" } / !'`````' c:. { c.ToString() }
SET_BASE_INDENTATION = spaces:" "* #{ if ((int)state["BaseIndentation"] == -1) state["BaseIndentation"] = spaces.Count; }
PUSH_INDENTATION = spaces:" "* #{ state["NormalizedIndent"] = spaces.Count - ((int)state["BaseIndentation"] == -1 ? 0 : (int)state["BaseIndentation"]); if ((int)state["NormalizedIndent"] < 0) state["NormalizedIndent"] = 0; } &{ (int)state["NormalizedIndent"] > (int)state["IndentationStack"].Peek() } #{ state["IndentationStack"].Push((int)state["NormalizedIndent"]); }
POP_INDENTATION = #{ state["IndentationStack"].Pop(); }
CHECK_INDENTATION = spaces:" "* #{ state["NormalizedIndent"] = spaces.Count - ((int)state["BaseIndentation"] == -1 ? 0 : (int)state["BaseIndentation"]); if ((int)state["NormalizedIndent"] < 0) state["NormalizedIndent"] = 0; } &{ (int)state["NormalizedIndent"] >= (int)state["IndentationStack"].Peek() }
eol = __ ("" [\r\n]+ / eof)
eof = !.
__ = [ \t]*
_ = whiteSpaceSymbol*
whiteSpaceSymbol = [ \t\n\r]
referenceSymbol = [^ \t\n\r(:)]
