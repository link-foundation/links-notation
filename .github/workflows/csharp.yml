name: csharp

on:
  push:
    branches: main 
    paths:
      - 'csharp/**'
      - '.github/workflows/csharp.yml'
env:
  NUGETTOKEN: ${{ secrets.NUGET_TOKEN }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  SCRIPTS_BASE_URL: https://raw.githubusercontent.com/linksplatform/Scripts/main/MultiProjectRepository

defaults:
  run:
    working-directory: csharp

jobs:
  findChangedCsFiles:
    runs-on: ubuntu-latest
    outputs:
      isCsFilesChanged: ${{ steps.setIsCsFilesChangedOutput.outputs.isCsFilesChanged }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Get changed files using defaults
        id: changed-files
        uses: tj-actions/changed-files@v46
      - name: Set output isCsFilesChanged
        id: setIsCsFilesChangedOutput
        run: |
          isCsFilesChanged='false'
          echo "Changed files: ${{ steps.changed-files.outputs.all_changed_files }}"
          for changedFile in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ $changedFile == csharp/*.cs ]] || [[ $changedFile == csharp/*.csproj ]] || [[ $changedFile == csharp/*.sln ]] || [[ $changedFile == csharp/* ]] || [[ $changedFile == .github/workflows/csharp.yml ]]; then
              echo "isCsFilesChanged='true'"
              isCsFilesChanged='true'
              break
            fi
          done
          echo "isCsFilesChanged=${isCsFilesChanged}" >> $GITHUB_OUTPUT
          echo "isCsFilesChanged: ${isCsFilesChanged}"

  test:
    needs: [findChangedCsFiles]
    if: ${{ needs.findChangedCsFiles.outputs.isCsFilesChanged == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x' # Specify your desired .NET version
      - name: Restore Dependencies
        run: dotnet restore
      - name: Build
        run: dotnet build --configuration Release --no-restore
      - name: Test
        run: dotnet test --configuration Release --no-build -f net8


  pushToNuget:
    runs-on: ubuntu-latest
    needs: [test]
    if: ${{ needs.findChangedCsFiles.outputs.isCsFilesChanged == 'true' }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x' # Ensure this matches your project's target
      - name: Check if version already published to NuGet.org
        id: nuget-version-check
        run: |
          PACKAGE_VERSION=$(grep '<VersionPrefix>' Platform.Protocols.Lino/Platform.Protocols.Lino.csproj | sed 's/.*<VersionPrefix>\(.*\)<\/VersionPrefix>.*/\1/')
          PACKAGE_ID="Platform.Protocols.Lino"
          echo "Package: $PACKAGE_ID@$PACKAGE_VERSION"
          
          # Check if version exists on NuGet.org
          if curl -f "https://api.nuget.org/v3-flatcontainer/$PACKAGE_ID/$PACKAGE_VERSION/$PACKAGE_ID.nuspec" > /dev/null 2>&1; then
            echo "Version $PACKAGE_VERSION already exists on NuGet.org"
            echo "should_publish=false" >> $GITHUB_OUTPUT
          else
            echo "Version $PACKAGE_VERSION does not exist on NuGet.org"
            echo "should_publish=true" >> $GITHUB_OUTPUT
          fi
      - name: Read project information
        if: steps.nuget-version-check.outputs.should_publish == 'true'
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/read_csharp_package_info.sh"
          bash ./read_csharp_package_info.sh
      - name: Publish NuGet package
        if: steps.nuget-version-check.outputs.should_publish == 'true'
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/push-csharp-nuget.sh"
          bash ./push-csharp-nuget.sh

  publishRelease:
    runs-on: ubuntu-latest
    needs: [pushToNuget, publishDocumentation]
    if: ${{ needs.findChangedCsFiles.outputs.isCsFilesChanged == 'true' && needs.pushToNuget.result == 'success' }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x' # Ensure this matches your project's target
      - name: Read project information
        if: ${{ github.event_name == 'push' }}
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/read_csharp_package_info.sh"
          
          # Debug: Check apt lock status
          echo "=== APT lock debug ==="
          lsof /var/lib/dpkg/lock-frontend 2>/dev/null || echo "No process holding dpkg lock"
          ps aux | grep -i apt || echo "No apt processes found"
          
          # Wait for any running apt processes to finish
          while sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
            echo "Waiting for other apt process to finish..."
            sleep 5
          done
          
          # Add retry logic for apt operations in the script
          sed -i 's/sudo apt-get install/sudo apt-get install --fix-missing -y/g' ./read_csharp_package_info.sh
          
          bash ./read_csharp_package_info.sh
      - name: Publish release
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/publish-release.sh"
          chmod +x ./publish-release.sh
          wget "$SCRIPTS_BASE_URL/publish-csharp-release.sh"

          # Override tag format to use version_language instead of language_version
          sed -i 's/csharp_\$PACKAGE_VERSION/\${PACKAGE_VERSION}_csharp/g' ./publish-csharp-release.sh

          bash ./publish-csharp-release.sh
  generatePdfWithCode:
    runs-on: ubuntu-latest
    needs: [test]
    if: ${{ needs.findChangedCsFiles.outputs.isCsFilesChanged == 'true' }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x' # Ensure this matches your project's target
      - name: Install dependencies for PDF generation
        run: |
          sudo apt-get update
          sudo apt-get install -y texlive texlive-lang-cyrillic texlive-latex-extra python3-pygments ghostscript python-is-python3
      - name: Generate PDF with code
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/format-csharp-files.py"
          wget "$SCRIPTS_BASE_URL/format-csharp-document.sh"
          wget "$SCRIPTS_BASE_URL/generate-csharp-pdf.sh"
          
          # Debug: Show downloaded files and their encoding
          echo "=== Downloaded files debug ==="
          ls -la *.py *.sh
          file format-csharp-files.py
          hexdump -C format-csharp-files.py | head -5
          
          # Remove BOM (Byte Order Mark) if present
          sed -i '1s/^\xEF\xBB\xBF//' ./format-csharp-files.py
          
          # Replace python-pygments with python3-pygments and python2 with python3
          sed -i 's/python-pygments/python3-pygments/g' ./generate-csharp-pdf.sh
          sed -i 's/python2/python3/g' ./format-csharp-document.sh
          # Fix Python 3 compatibility in format-csharp-files.py
          sed -i 's/reload(sys)/importlib.reload(sys)/g' ./format-csharp-files.py
          sed -i '1i import importlib' ./format-csharp-files.py
          # Also remove sys.setdefaultencoding which doesn't exist in Python 3
          sed -i '/sys.setdefaultencoding/d' ./format-csharp-files.py
          
          # Debug: Show file after fixes
          echo "=== After fixes ==="
          file format-csharp-files.py
          head -5 format-csharp-files.py
          
          bash ./generate-csharp-pdf.sh

  publishDocumentation:
    runs-on: ubuntu-latest
    needs: [test, generatePdfWithCode]
    if: ${{ needs.findChangedCsFiles.outputs.isCsFilesChanged == 'true' }}
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x' # Ensure this matches your project's target
      - name: Install dependencies for documentation
        run: |
          # Install docfx using dotnet tool instead of nuget
          sudo apt-get update
          sudo apt-get install -y mono-complete || echo "Mono installation not required"
          
          # Install docfx as a dotnet global tool
          dotnet tool install -g docfx
          
          # Add dotnet tools to PATH
          echo "~/.dotnet/tools" >> $GITHUB_PATH
      - name: Publish documentation to gh-pages branch
        run: |
          export REPOSITORY_NAME=$(basename ${{ github.repository }})
          wget "$SCRIPTS_BASE_URL/docfx.json"
          wget "$SCRIPTS_BASE_URL/filter.yml"
          wget "$SCRIPTS_BASE_URL/toc.yml"
          wget "$SCRIPTS_BASE_URL/publish-csharp-docs.sh"
          
          # Debug: Check if docfx is available
          echo "=== DocFX availability debug ==="
          which docfx || echo "docfx not found in PATH"
          dotnet tool list -g | grep docfx || echo "docfx not installed as global tool"
          
          # Replace nuget commands and mono calls with docfx directly
          sed -i 's/sudo apt-get install.*nuget.*/echo "Skipping nuget installation"/g' ./publish-csharp-docs.sh
          sed -i 's/nuget install docfx.console.*$/echo "Skipping docfx installation via nuget"/g' ./publish-csharp-docs.sh
          sed -i 's/mono.*docfx.exe.*docfx.json/docfx docfx.json/g' ./publish-csharp-docs.sh
          # Also replace the line that directly calls nuget install without sudo apt-get
          sed -i 's/^nuget install docfx.console.*$/echo "Skipping docfx installation via nuget"/g' ./publish-csharp-docs.sh
          # Remove --force flag as it's not supported in DocFX 2.78.3
          sed -i 's/^docfx docfx.json --force$/docfx docfx.json/g' ./publish-csharp-docs.sh
          
          # Clean up ALL build artifacts to avoid conflicts
          echo "=== Cleaning up ALL build artifacts ==="
          find . -type d -name "obj" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "bin" -exec rm -rf {} + 2>/dev/null || true
          rm -rf _site 2>/dev/null || true
          
          # Debug: Show project structure
          echo "=== Project structure debug ==="
          find . -name "*.csproj" -o -name "*.sln" | head -10
          echo "Current directory: $(pwd)"
          ls -la
          
          # Skip the build - the test job already validated it builds correctly
          # DocFX will build what it needs internally
          
          # Debug: Show modified script
          echo "=== Modified script debug ==="
          cat ./publish-csharp-docs.sh
          
          # Debug: Check PATH and docfx availability before running script
          echo "=== PATH debug ==="
          echo "PATH: $PATH"
          export PATH="$HOME/.dotnet/tools:$PATH"
          echo "Updated PATH: $PATH"
          which docfx || echo "docfx still not found"
          
          # Ensure the script uses the updated PATH
          export PATH="$HOME/.dotnet/tools:$PATH"
          
          # Debug: Test docfx before running script
          echo "=== DocFX test ==="
          docfx --version || echo "DocFX version command failed"
          docfx --help | head -5 || echo "DocFX help command failed"
          
          # Fix DocFX target framework to match our project
          echo "=== Fixing DocFX target framework ==="
          sed -i 's/"TargetFramework": "netstandard2.0"/"TargetFramework": "net8"/g' docfx.json
          
          # Debug: Show updated docfx.json content
          echo "=== DocFX configuration (after fix) ==="
          cat docfx.json || echo "No docfx.json found"
          
          echo "=== Running documentation script ==="
          bash -x ./publish-csharp-docs.sh 2>&1 | tee docfx_output.log
          SCRIPT_EXIT_CODE=$?
          
          if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
            echo "=== Script failed with exit code $SCRIPT_EXIT_CODE ==="
            echo "Last 100 lines of output:"
            tail -100 docfx_output.log || echo "No log file"
            echo "=== Checking if documentation was still generated ==="
            if [ -d "_site" ]; then
              echo "✅ _site directory exists, continuing with deployment despite errors"
              ls -la _site/ | head -10
            else
              echo "❌ No _site directory found, documentation generation completely failed"
              exit 1
            fi
          else
            echo "✅ Script completed successfully"
          fi
          
          echo "=== Final documentation check ==="
          ls -la _site/ 2>/dev/null || echo "No _site directory found"
