name: go

on:
  push:
    branches: main
    paths:
      - 'go/**'
      - '.github/workflows/go.yml'
  pull_request:
    paths:
      - 'go/**'
      - '.github/workflows/go.yml'

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

defaults:
  run:
    working-directory: go

jobs:
  findChangedGoFiles:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      isGoFilesChanged: ${{ steps.setIsGoFilesChangedOutput.outputs.isGoFilesChanged }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Get changed files using defaults
        id: changed-files
        uses: tj-actions/changed-files@v47
      - name: Set output isGoFilesChanged
        id: setIsGoFilesChangedOutput
        run: |
          isGoFilesChanged='false'
          echo "Changed files: ${{ steps.changed-files.outputs.all_changed_files }}"
          for changedFile in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ $changedFile == go/*.go ]] || [[ $changedFile == go/go.mod ]] || [[ $changedFile == go/go.sum ]] || [[ $changedFile == go/* ]] || [[ $changedFile == .github/workflows/go.yml ]]; then
              echo "isGoFilesChanged='true'"
              isGoFilesChanged='true'
              break
            fi
          done
          echo "isGoFilesChanged=${isGoFilesChanged}" >> $GITHUB_OUTPUT
          echo "isGoFilesChanged: ${isGoFilesChanged}"

  lint:
    needs: [findChangedGoFiles]
    if: ${{ needs.findChangedGoFiles.outputs.isGoFilesChanged == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true
      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.21'
          cache-dependency-path: go/go.sum
      - name: Check formatting
        run: |
          gofmt_output=$(gofmt -l .)
          if [ -n "$gofmt_output" ]; then
            echo "The following files are not formatted correctly:"
            echo "$gofmt_output"
            exit 1
          fi
      - name: Run go vet
        run: go vet ./...

  test:
    needs: [findChangedGoFiles, lint]
    if: ${{ needs.findChangedGoFiles.outputs.isGoFilesChanged == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true
      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.21'
          cache-dependency-path: go/go.sum
      - name: Build
        run: go build -v ./...
      - name: Test
        run: go test -v -race -coverprofile=coverage.out ./...
      - name: Upload coverage
        uses: codecov/codecov-action@v5
        with:
          files: go/coverage.out
          flags: go
          fail_ci_if_error: false

  publishRelease:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [test, findChangedGoFiles]
    if: ${{ needs.findChangedGoFiles.outputs.isGoFilesChanged == 'true' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 0
      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.21'
      - name: Extract version from go.mod
        id: version-extract
        run: |
          # For Go modules, version is typically managed through git tags
          # We'll read the module path and create a version based on semantic versioning
          MODULE_PATH=$(grep "^module " go.mod | awk '{print $2}')
          echo "module_path=$MODULE_PATH" >> $GITHUB_OUTPUT

          # Get the latest tag for Go module (if any)
          LATEST_TAG=$(git describe --tags --match "go_*" --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            # If no tag exists, use version 0.13.0 to match other packages
            PACKAGE_VERSION="0.13.0"
          else
            # Extract version from tag (format: go_X.Y.Z)
            PACKAGE_VERSION="${LATEST_TAG#go_}"
          fi

          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "Go module: $MODULE_PATH"
          echo "Version: $PACKAGE_VERSION"
      - name: Check if GitHub release already exists
        id: release-check
        run: |
          PACKAGE_VERSION="${{ steps.version-extract.outputs.version }}"
          TAG_NAME="go_$PACKAGE_VERSION"
          echo "Checking if release $TAG_NAME already exists"

          # Check if release exists
          if gh release view "$TAG_NAME" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists"
            echo "should_create_release=false" >> $GITHUB_OUTPUT
          else
            echo "Release $TAG_NAME does not exist"
            echo "should_create_release=true" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Create GitHub release and tag
        if: steps.release-check.outputs.should_create_release == 'true'
        run: |
          PACKAGE_VERSION="${{ steps.version-extract.outputs.version }}"
          MODULE_PATH="${{ steps.version-extract.outputs.module_path }}"
          TAG_NAME="go_${PACKAGE_VERSION}"

          # Create and push tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Go module release $PACKAGE_VERSION"
          git push origin "$TAG_NAME"

          # Create GitHub release
          gh release create "$TAG_NAME" \
            --title "[Go] $PACKAGE_VERSION" \
            --notes "Go module release for \`$MODULE_PATH\`

          ## Installation

          \`\`\`bash
          go get $MODULE_PATH@$TAG_NAME
          \`\`\`

          ## Documentation

          https://pkg.go.dev/$MODULE_PATH@$TAG_NAME"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
